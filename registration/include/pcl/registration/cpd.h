/*
 * Software License Agreement (BSD License)
 *
 *  Point Cloud Library (PCL) - www.pointclouds.org
 *  Copyright (c) 2014-, Open Perception, Inc.
 *  Copyright (C) 2014-, University of Chinese Academy of Sciences, Xiaochen Fan, China.
 *
 *  All rights reserved
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met
 *
 *   * The use for research only (no for any commercial application).
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.
 *   * Neither the name of the copyright holder(s) nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifndef PCL_REGISTRATION_CPD_H_
#define PCL_REGISTRATION_CPD_H_

#include <pcl/common/common.h>

namespace pcl
{
  namespace registration
  {
    /** \brief A probabilistic framework for both rigid and non-rigid global registration.
      * \details This method has the following features: 
      * <ul>
      *  <li>The source points are represented as the centroids of Gaussian distributions so that Gaussian Mixture Model could be used to
      *      Model the source cloud. On other hand, the target points are observations which are assumed to be generated by source points.
      *  </li>
      *  <li>The correspondences between source points and target points are maintained by a M*N matrix, where each entry is the probability
      *      between the related point pair.
      *  </li>
      *  <li>The registration problem is regarded as maximum a posteriori estimation, which could be solved by EM framework.
      *  </li>
      * <\ul>
      * For more information:
      * <ul>
      *  <li> "Point Set Registration: Coherent Point Drift", Andriy Myronenko and Xubo Song.
      *       IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 32, issue 12, pp.2262-2275, 2010
      *  </li>
      * </ul>
      * Usage example:
      * \code
      * pcl::registration::CPD<pcl::PointXYZ> cpd;
      * // Set source cloud and target cloud
      * cpd.setSourceCloud (source_cloud);
      * cpd.setTargetCloud (target_cloud);
      * // Set Registration Type: RIGID and NONRIGID
      * cpd.setRegType(pcl::registration::CPD<pcl::PointXYZ>::NONRIGID);
      * // Set some parameters for rigid or non-rigid (optional)
      * cpd.setMaxIteration (50);
      * cpd.setVarienceTol (1e-5);
      * ......
      * // Start registration process, the source cloud will be changed
      * cpd.run ();
      * \endcode
      * \author Xiaochen Fan
      * \ingroup registration
      */
    template <typename PointT>
    class CPD
    {
    public:
      typedef boost::shared_ptr<CPD<PointT> > Ptr;
      typedef boost::shared_ptr<const CPD<PointT> > ConstPtr;

      typedef pcl::PointCloud<PointT> PointCloud;
      typedef typename PointCloud::Ptr PointCloudPtr;
      typedef typename PointCloud::ConstPtr PointCloudConstPtr;

      typedef Eigen::Matrix<float, Eigen::Dynamic, 1> VectorXf;
      typedef Eigen::Matrix<float, Eigen::Dynamic, 3, Eigen::RowMajor> Matrix3f;
      typedef Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor> MatrixXf;

      typedef enum {RIGID, NONRIGID} RegType;

      typedef struct  
      {
        MatrixXf r_;
        VectorXf t_;
        float s_;
        float sigma2_;
      }RigidParas;

      typedef struct  
      {
        MatrixXf w_;
        float sigma2_;
        float lambda_;
        float beta_;
      }NonRigidParas;

    public:
      /** \brief Constructor.
        * set default values for parameters.
        */
      CPD ();

      /** \brief Destructor. */
      virtual ~CPD ()
      {};

      /** \brief Set source cloud.
        */
      inline void
      setSourceCloud (const PointCloudPtr& source_cloud)
      {
        source_cloud_ = source_cloud;
      }

      /** \brief Set target cloud.
        */
      inline void
      setTargetCloud (const PointCloudPtr& target_cloud)
      {
        target_cloud_ = target_cloud;
      }

      /** \brief Get source cloud.
        */
      inline PointCloudConstPtr
      getSourceCloud () const 
      {
        return (source_cloud_);
      }
      
      /** \brief Get target cloud.
        */
      inline PointCloudConstPtr
      getTargetCloud () const
      {
        return (target_cloud_);
      }
      
      /** \brief Set the maximum number of iteration.
        */
      inline void
      setMaxIteration (size_t max_iters)
      {
        max_iters_ = max_iters;
      }

      /** \brief Get the maximum number of iteration.
        */
      inline size_t
      getMaxInteration () const
      {
        return (max_iters_);
      }

      /** \brief Set the variance tolerance.
        */
      inline void
      setVarianceTol (float var_tol)
      {
        var_tol_ = var_tol;
      }

      /** \brief Get the variance tolerance.
        */
      inline float
      getVarianceTol () const
      {
        return (var_tol_);
      }

      /** \brief Set the energy tolerance.
        */
      inline void
      setEnergyTol (float energy_tol)
      {
        energy_tol_ = energy_tol;
      }

      /** \brief Get the energy tolerance.
        */
      inline float
      getEnergyTol () const
      {
        return (energy_tol_);
      }

      /** \brief Set the outliers weight.
        */
      inline void
      setOutlierWeight (float w)
      {
        w_ = w;
      }

      /** \brief Get the outliers weight.
        */
      inline float
      getOutlierWeight () const
      {
        return (w_);
      }

      /** \brief Set the lambda.
        */
      inline void
      setLambda (float lambda)
      {
        nrigid_paras_.lambda_ = lambda;
      }

      /** \brief Get the lambda.
        */
      inline float
      getLambda () const
      {
        return (nrigid_paras_.lambda_);
      }

      /** \brief Set the beta.
        */
      inline void
      setBeta (float beta)
      {
        nrigid_paras_.beta_ = beta;
      }

      /** \brief Get the beta.
        */
      inline float
      getBeta () const
      {
        return (nrigid_paras_.beta_);
      }

      /** \brief Set the registration type.
        */
      inline void
      setRegType (RegType reg_type)
      {
        reg_type_ = reg_type;
      }

      /** \brief Get the registration type.
        */
      inline RegType
      getRegType () const
      {
        return (reg_type_);
      }

      /** \brief Run the registration method.
        */
      void
      run ();

      /** \brief Compute the rigid registration method explicitly.
        */
      void
      computeRigid ();

      /** \brief Compute the non-rigid registration method explicitly.
        */
      void
      computeNonRigid ();


    protected:

      inline void
      initTransform ()
      {
        transform_ = source_mat_;
      }

      inline void
      updateSourceMat ()
      {
        source_mat_ = transform_;
      }

      void 
      initMats ();

      void
      updateClouds ();

      void
      normalize ();

      void
      denormalize ();


    protected:
      void
      initialize ();

      void
      e_step ();

      void
      m_step ();

      void
      align ();

      void
      computeCorres ();

      void
      constructG ();

      float
      computeGaussianExp (size_t m, size_t n);

      float
      energy ();


    protected:

      PointCloudPtr source_cloud_;
      PointCloudPtr target_cloud_;

      Matrix3f source_mat_;
      Matrix3f target_mat_;

      Matrix3f transform_;

      MatrixXf corres_;
      RegType reg_type_;

      size_t max_iters_;
      float energy_tol_;
      float var_tol_;
      float w_;

      VectorXf source_means_;
      float source_scale_;

      VectorXf target_means_;
      float target_scale_;

      RigidParas rigid_paras_;
      NonRigidParas nrigid_paras_;

      MatrixXf p1_;
      MatrixXf pt1_;
      MatrixXf px_;

      MatrixXf g_;

    };
  }; // namespace registration  
}; // namespace pcl 

#include <pcl/registration/impl/cpd.hpp>

#endif // PCL_REGISTRATION_CPD_H_
